flow = {}

if module?.exports
  module.exports = flow
else if define?.amd
  define -> flow
else
  @flow = flow

# defines a flow given any number of functions as arguments
flow.define = ->
  thisFlow = ->
    thisFlow.exec.apply thisFlow, Array::slice.call arguments

  thisFlow.blocks = arguments
  thisFlow.exec = ->
    
    # The flowState is the actual object each step in the flow is applied to. It acts as a
    # callback to the next function. It also maintains the internal state of each execution
    # and acts as a place for users to save values between steps of the flow.
    flowState = ->
      return  if flowState.__frozen
      if flowState.__timeoutId
        clearTimeout flowState.__timeoutId
        delete flowState.__timeoutId
      blockIdx = flowState.__nextBlockIdx++
      block = thisFlow.blocks[blockIdx]
      if block is undefined
        return
      else
        block.apply flowState, Array::slice.call arguments

    # __nextBlockIdx specifies which function is the next step in the flow.
    flowState.__nextBlockIdx = 0

    # __multiCount is incremented every time MULTI is used to createa a multiplexed callback
    flowState.__multiCount = 0

    # __multiOutputs accumulates the arguments of each call to callbacks generated by MULTI
    flowState.__multiOutputs = []

    # REWIND signals that the next call to thisFlow should repeat this step. It allows you
    # to create serial loops.
    flowState.REWIND = ->
      flowState.__nextBlockIdx -= 1

    # MULTI can be used to generate callbacks that must ALL be called before the next step
    # in the flow is executed. Arguments to those callbacks are accumulated, and an array of
    # of those arguments objects is sent as the one argument to the next step in the flow.
    # @param {String} resultId An identifier to get the result of a multi call.
    flowState.MULTI = (resultId) ->
      resultId ||= flowState.__multiCount
      flowState.__multiCount += 1
      ->
        flowState.__multiCount -= 1
        flowState.__multiOutputs[resultId] = arguments
        if flowState.__multiCount is 0
          multiOutputs = flowState.__multiOutputs
          flowState.__multiOutputs = []
          flowState multiOutputs

    # TIMEOUT sets a timeout that freezes a flow and calls the provided callback. This
    # timeout is cleared if the next flow step happens first.
    flowState.TIMEOUT = (milliseconds, timeoutCallback) ->
      throw new Error("timeout already set for this flow step")  if flowState.__timeoutId isnt undefined
      flowState.__timeoutId = setTimeout(
        ->
          flowState.__frozen = true
          timeoutCallback()
        milliseconds
      )

    flowState.apply @, Array::slice.call arguments

  thisFlow

# defines a flow and evaluates it immediately. The first flow function won't receive any arguments.
flow.exec = ->
  flow.define.apply(flow, Array::slice.call arguments)()

flow.serialForEach = flow.define(
  (items, job, between, finish) ->
    @items = items
    @curItem = 0
    @job = job
    @between = between
    @finish = finish
    @()
  ->
    @between.apply @, Array::slice.call arguments  if @curItem > 0 and @between
    if @curItem >= @items.length
      @()
    else
      @REWIND()
      @curItem += 1
      @job @items[@curItem - 1]
  ->
    @finish && @finish()
)

# helper methods
flow.anyError = (results) ->
  for result in results
    return result[0] if result && result[0]
  null

flow.returnIfAnyError = (results, callback) ->
  err = @anyError results
  return false unless err
  callback && callback err
  true
